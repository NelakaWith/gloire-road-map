name: Deploy

on:
  workflow_dispatch: {}
  push:
    tags:
      - "v*"
  release:
    types: [published, created]
  workflow_run:
    workflows: ["Release"]
    types: [completed]

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      deployments: write
    if: ${{ github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success' }}
    env:
      DEPLOY_TAG: ${{ github.event_name == 'release' && github.event.release.tag_name || (github.ref_type == 'tag' && github.ref_name) || '' }}
    steps:
      - name: Determine DEPLOY_TAG from latest release (when triggered by Release workflow)
        if: ${{ github.event_name == 'workflow_run' }}
        uses: actions/github-script@v6
        with:
          script: |
            // Query the repository for the most recent release and export its tag
            const latest = await github.rest.repos.getLatestRelease({
              owner: context.repo.owner,
              repo: context.repo.repo
            });
            const tag = latest.data.tag_name;
            require('fs').appendFileSync(process.env.GITHUB_ENV, `DEPLOY_TAG=${tag}\n`);
            console.log(`Determined DEPLOY_TAG=${tag}`);
            return tag;

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true
          ref: ${{ env.DEPLOY_TAG != '' && env.DEPLOY_TAG || (github.event_name == 'release' && github.event.release.tag_name || github.ref) }}

      - name: Create GitHub Deployment
        id: create_deployment
        uses: actions/github-script@v6
        with:
          script: |
            try {
              const ref = process.env.DEPLOY_TAG || github.ref;
              console.log('Creating deployment for ref:', ref);
              const response = await github.rest.repos.createDeployment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: ref,
                required_contexts: [],
                environment: 'production',
                auto_merge: false,
                description: 'Deployment triggered by CI',
                transient_environment: false
              });
              const id = response && response.data && response.data.id ? String(response.data.id) : '';
              console.log('Create deployment response id:', id);
              console.log('Full response data:', JSON.stringify(response.data || {}));
              // Export a clean numeric id to GITHUB_ENV so later steps can read it reliably
              try {
                require('fs').appendFileSync(process.env.GITHUB_ENV, `DEPLOYMENT_ID=${id}\n`);
                console.log('Exported DEPLOYMENT_ID to GITHUB_ENV');
              } catch (e) {
                console.warn('Failed to write DEPLOYMENT_ID to GITHUB_ENV:', String(e));
              }
              // Mark the deployment as in_progress so the GitHub UI doesn't show it as "Ready to deploy (idle)"
              try {
                const numericId = Number(id);
                if (numericId && !Number.isNaN(numericId)) {
                  console.log('Setting deployment status to in_progress for id:', numericId);
                  await github.rest.repos.createDeploymentStatus({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    deployment_id: numericId,
                    state: 'in_progress',
                    description: 'Deployment started by CI',
                    environment: 'production'
                  });
                } else {
                  console.log('Skipping in_progress status: invalid deployment id');
                }
              } catch (err) {
                console.error('Failed to set in_progress status:', String(err));
              }
              core.setOutput('result', id);
              if (!id) throw new Error('createDeployment returned empty id');
              return id;
            } catch (err) {
              console.error('Create deployment failed:', String(err));
              throw err;
            }

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Build frontend
        working-directory: frontend
        run: |
          npm install
          npm run build

      - name: Clone repository on droplet
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DROPLET_HOST }}
          username: ${{ secrets.DROPLET_USER }}
          key: ${{ secrets.DROPLET_SSH_KEY }}
          script: |
            # Remove old deployment
            rm -rf ~/gloire-road-map

            # Clone the specific tag/version
            git clone https://github.com/${{ github.repository }}.git ~/gloire-road-map
            cd ~/gloire-road-map

            # Checkout the specific tag being deployed
            DEPLOY_TAG="${{ env.DEPLOY_TAG }}"
            if [ -n "$DEPLOY_TAG" ]; then
              echo "Checking out tag: $DEPLOY_TAG"
              git checkout "$DEPLOY_TAG"
            else
              echo "No specific tag, using latest from main"
              git checkout main
            fi

            echo "Deployed version:"
            git log -1 --oneline
            echo "Current package version:"
            cat package.json | grep '"version"' || echo "No package.json found"

      - name: Run deploy script on droplet
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DROPLET_HOST }}
          username: ${{ secrets.DROPLET_USER }}
          key: ${{ secrets.DROPLET_SSH_KEY }}
          script: |
            cd ~/gloire-road-map/backend

            # Create .env file from GitHub secrets
            echo "Creating .env file from secrets..."
            # Use a quoted heredoc delimiter so the shell does NOT perform parameter expansion
            # on the embedded secret values (prevents truncation when the secret contains $ or similar)
            cat > .env << 'EOF'
            # Backend environment variables (auto-generated by deploy script)
            PORT=3005
            CORS_ORIGIN=https://roadmap.nelakawithanage.com/

            # Database configuration
            DB_HOST=127.0.0.1
            DB_NAME="${{ secrets.DB_NAME }}"
            DB_USER="${{ secrets.DB_USER }}"
            DB_PASSWORD="${{ secrets.DB_PASS }}"

            # JWT secret for authentication
            JWT_SECRET="${{ secrets.JWT_SECRET }}"
            EOF

            npm install
            pm2 restart server.js || pm2 start server.js --name gloire-road-map-backend
            cd ~/gloire-road-map/frontend
            npm install
            npm run build

            # Copy frontend build directly to nginx directory
            if sudo -n true 2>/dev/null; then
              echo "Updating nginx directory..."
              sudo mkdir -p /var/www/gloire-road-map-live
              sudo rm -rf /var/www/gloire-road-map-live/* || true
              sudo cp -r dist/* /var/www/gloire-road-map-live/ || true
              sudo chown -R www-data:www-data /var/www/gloire-road-map-live || true
              echo "Nginx directory updated successfully"
            else
              echo "No sudo access - manual step required:"
              echo "sudo cp -r ~/gloire-road-map/frontend/dist/* /var/www/gloire-road-map-live/"
            fi

            # (Optional) Restart nginx if using static hosting
            if sudo -n true 2>/dev/null; then
              sudo systemctl reload nginx || echo "nginx reload failed"
            else
              echo "Skipping nginx reload: deploy user cannot run sudo without a password"
            fi

      - name: Mark deployment as successful
        if: ${{ success() && steps.create_deployment.outputs.result != '' }}
        uses: actions/github-script@v6
        env:
          DEPLOYMENT_ID: ${{ steps.create_deployment.outputs.result }}
        with:
          script: |
            try {
              const raw = process.env.DEPLOYMENT_ID || '';
              // Strip any non-digit characters (handles quoted values like "3060155420")
              const digits = String(raw).replace(/\D/g, '');
              const deploymentId = Number(digits);
              if (!digits || Number.isNaN(deploymentId) || deploymentId <= 0) {
                console.log('No valid deployment id found, skipping createDeploymentStatus (success)');
                return;
              }
              await github.rest.repos.createDeploymentStatus({
                owner: context.repo.owner,
                repo: context.repo.repo,
                deployment_id: deploymentId,
                state: 'success',
                description: 'Deployment succeeded',
                environment: 'production'
              });
            } catch (err) {
              console.log('createDeploymentStatus (success) skipped due to error:', String(err));
            }

      - name: Mark deployment as failed
        if: ${{ failure() && steps.create_deployment.outputs.result != '' }}
        uses: actions/github-script@v6
        env:
          DEPLOYMENT_ID: ${{ steps.create_deployment.outputs.result }}
        with:
          script: |
            try {
              const raw = process.env.DEPLOYMENT_ID || '';
              const digits = String(raw).replace(/\D/g, '');
              const deploymentId = Number(digits);
              if (!digits || Number.isNaN(deploymentId) || deploymentId <= 0) {
                console.log('No valid deployment id found, skipping createDeploymentStatus (failure)');
                return;
              }
              await github.rest.repos.createDeploymentStatus({
                owner: context.repo.owner,
                repo: context.repo.repo,
                deployment_id: deploymentId,
                state: 'failure',
                description: 'Deployment failed',
                environment: 'production'
              });
            } catch (err) {
              console.log('createDeploymentStatus (failure) skipped due to error:', String(err));
            }
