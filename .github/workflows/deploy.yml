name: Deploy

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Deployment environment"
        required: true
        default: "production"
        type: choice
        options:
          - production
          - demo
  release:
    types: [published, created]
  workflow_run:
    workflows: ["Release"]
    types: [completed]

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      deployments: write
    if: ${{ github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success' }}
    env:
      DEPLOY_TAG: ${{ github.event_name == 'release' && github.event.release.tag_name || (github.ref_type == 'tag' && github.ref_name) || '' }}
      DEPLOY_ENV: ${{ github.event.inputs.environment || 'production' }}
    steps:
      - name: Determine DEPLOY_TAG from latest release (when triggered by Release workflow)
        if: ${{ github.event_name == 'workflow_run' }}
        uses: actions/github-script@v6
        with:
          script: |
            // Query the repository for the most recent release and export its tag
            const latest = await github.rest.repos.getLatestRelease({
              owner: context.repo.owner,
              repo: context.repo.repo
            });
            const tag = latest.data.tag_name;
            require('fs').appendFileSync(process.env.GITHUB_ENV, `DEPLOY_TAG=${tag}\n`);
            console.log(`Determined DEPLOY_TAG=${tag}`);
            return tag;

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true
          ref: ${{ env.DEPLOY_TAG != '' && env.DEPLOY_TAG || (github.event_name == 'release' && github.event.release.tag_name || github.ref) }}

      - name: Create GitHub Deployment
        id: create_deployment
        uses: actions/github-script@v6
        with:
          script: |
            try {
              const ref = process.env.DEPLOY_TAG || github.ref;
              console.log('Creating deployment for ref:', ref);
              const response = await github.rest.repos.createDeployment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: ref,
                required_contexts: [],
                environment: '${{ env.DEPLOY_ENV }}',
                auto_merge: false,
                description: 'Deployment triggered by CI',
                transient_environment: false
              });
              const id = response && response.data && response.data.id ? String(response.data.id) : '';
              console.log('Create deployment response id:', id);
              console.log('Full response data:', JSON.stringify(response.data || {}));
              // Export a clean numeric id to GITHUB_ENV so later steps can read it reliably
              try {
                require('fs').appendFileSync(process.env.GITHUB_ENV, `DEPLOYMENT_ID=${id}\n`);
                console.log('Exported DEPLOYMENT_ID to GITHUB_ENV');
              } catch (e) {
                console.warn('Failed to write DEPLOYMENT_ID to GITHUB_ENV:', String(e));
              }
              // Mark the deployment as in_progress so the GitHub UI doesn't show it as "Ready to deploy (idle)"
              try {
                const numericId = Number(id);
                if (numericId && !Number.isNaN(numericId)) {
                  console.log('Setting deployment status to in_progress for id:', numericId);
                  await github.rest.repos.createDeploymentStatus({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    deployment_id: numericId,
                    state: 'in_progress',
                    description: 'Deployment started by CI',
                    environment: '${{ env.DEPLOY_ENV }}'
                  });
                } else {
                  console.log('Skipping in_progress status: invalid deployment id');
                }
              } catch (err) {
                console.error('Failed to set in_progress status:', String(err));
              }
              core.setOutput('result', id);
              if (!id) throw new Error('createDeployment returned empty id');
              return id;
            } catch (err) {
              console.error('Create deployment failed:', String(err));
              throw err;
            }

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Build frontend
        working-directory: frontend
        run: |
          npm install
          npm run build

      - name: Clone repository on droplet
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DROPLET_HOST }}
          username: ${{ secrets.DROPLET_USER }}
          key: ${{ secrets.DROPLET_SSH_KEY }}
          script: |
            # Set deployment folder based on environment
            if [ "${{ env.DEPLOY_ENV }}" = "demo" ]; then
              DEPLOY_FOLDER="gloire-road-map-demo"
              NGINX_FOLDER="/var/www/gloire-road-map-demo"
            else
              DEPLOY_FOLDER="gloire-road-map"
              NGINX_FOLDER="/var/www/gloire-road-map-live"
            fi

            echo "Deploying to environment: ${{ env.DEPLOY_ENV }}"
            echo "Using folder: $DEPLOY_FOLDER"
            echo "Nginx folder: $NGINX_FOLDER"

            # Remove old deployment
            rm -rf ~/$DEPLOY_FOLDER

            # Clone the specific tag/version
            git clone https://github.com/${{ github.repository }}.git ~/$DEPLOY_FOLDER
            cd ~/$DEPLOY_FOLDER

            # Checkout the specific tag being deployed
            DEPLOY_TAG="${{ env.DEPLOY_TAG }}"
            if [ -n "$DEPLOY_TAG" ]; then
              echo "Checking out tag: $DEPLOY_TAG"
              git checkout "$DEPLOY_TAG"
            else
              echo "No specific tag, using latest from main"
              git checkout main
            fi

            echo "Deployed version:"
            git log -1 --oneline
            echo "Current package version:"
            cat package.json | grep '"version"' || echo "No package.json found"

      - name: Run deploy script on droplet
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DROPLET_HOST }}
          username: ${{ secrets.DROPLET_USER }}
          key: ${{ secrets.DROPLET_SSH_KEY }}
          script: |
            # Set deployment folder and configuration based on environment
            if [ "${{ env.DEPLOY_ENV }}" = "demo" ]; then
              DEPLOY_FOLDER="gloire-road-map-demo"
              NGINX_FOLDER="/var/www/gloire-road-map-demo"
              BACKEND_PORT="3004"
              CORS_ORIGIN="https://demo.roadmap.nelakawithanage.com/"
              PM2_NAME="gloire-road-map-backend-demo"
            else
              DEPLOY_FOLDER="gloire-road-map"
              NGINX_FOLDER="/var/www/gloire-road-map-live"
              BACKEND_PORT="3005"
              CORS_ORIGIN="https://roadmap.nelakawithanage.com/"
              PM2_NAME="gloire-road-map-backend"
            fi

            echo "Deploying ${{ env.DEPLOY_ENV }} environment to folder: $DEPLOY_FOLDER"
            echo "Backend port: $BACKEND_PORT"
            echo "CORS origin: $CORS_ORIGIN"
            echo "PM2 process name: $PM2_NAME"

            cd ~/$DEPLOY_FOLDER/backend

            # Create .env file from GitHub secrets
            echo "Creating .env file from secrets..."
            cat > .env << EOF
            # Backend environment variables (auto-generated by deploy script)
            PORT=$BACKEND_PORT
            CORS_ORIGIN=$CORS_ORIGIN

            # Database configuration
            DB_HOST=127.0.0.1
            DB_NAME="${{ env.DEPLOY_ENV == 'demo' && secrets.DEMO_DB_NAME || secrets.DB_NAME }}"
            DB_USER="${{ env.DEPLOY_ENV == 'demo' && secrets.DEMO_DB_USER || secrets.DB_USER }}"
            DB_PASSWORD="${{ env.DEPLOY_ENV == 'demo' && secrets.DEMO_DB_PASS || secrets.DB_PASS }}"

            # JWT secret for authentication
            JWT_SECRET="${{ secrets.JWT_SECRET }}"
            EOF

            npm install
            pm2 restart $PM2_NAME || pm2 start server.js --name $PM2_NAME

            cd ~/$DEPLOY_FOLDER/frontend
            npm install
            npm run build

            # Copy frontend build directly to nginx directory
            if sudo -n true 2>/dev/null; then
              echo "Updating nginx directory: $NGINX_FOLDER"
              sudo mkdir -p $NGINX_FOLDER
              sudo rm -rf $NGINX_FOLDER/* || true
              sudo cp -r dist/* $NGINX_FOLDER/ || true
              sudo chown -R www-data:www-data $NGINX_FOLDER || true
              echo "Nginx directory updated successfully for ${{ env.DEPLOY_ENV }}"
            else
              echo "No sudo access - manual step required:"
              echo "sudo cp -r ~/$DEPLOY_FOLDER/frontend/dist/* $NGINX_FOLDER/"
            fi

            # (Optional) Restart nginx if using static hosting
            if sudo -n true 2>/dev/null; then
              sudo systemctl reload nginx || echo "nginx reload failed"
            else
              echo "Skipping nginx reload: deploy user cannot run sudo without a password"
            fi

      - name: Mark deployment as successful
        if: ${{ success() && steps.create_deployment.outputs.result != '' }}
        uses: actions/github-script@v6
        env:
          DEPLOYMENT_ID: ${{ steps.create_deployment.outputs.result }}
        with:
          script: |
            try {
              const raw = process.env.DEPLOYMENT_ID || '';
              // Strip any non-digit characters (handles quoted values like "3060155420")
              const digits = String(raw).replace(/\D/g, '');
              const deploymentId = Number(digits);
              if (!digits || Number.isNaN(deploymentId) || deploymentId <= 0) {
                console.log('No valid deployment id found, skipping createDeploymentStatus (success)');
                return;
              }
              await github.rest.repos.createDeploymentStatus({
                owner: context.repo.owner,
                repo: context.repo.repo,
                deployment_id: deploymentId,
                state: 'success',
                description: 'Deployment succeeded',
                environment: '${{ env.DEPLOY_ENV }}'
              });
            } catch (err) {
              console.log('createDeploymentStatus (success) skipped due to error:', String(err));
            }

      - name: Mark deployment as failed
        if: ${{ failure() && steps.create_deployment.outputs.result != '' }}
        uses: actions/github-script@v6
        env:
          DEPLOYMENT_ID: ${{ steps.create_deployment.outputs.result }}
        with:
          script: |
            try {
              const raw = process.env.DEPLOYMENT_ID || '';
              const digits = String(raw).replace(/\D/g, '');
              const deploymentId = Number(digits);
              if (!digits || Number.isNaN(deploymentId) || deploymentId <= 0) {
                console.log('No valid deployment id found, skipping createDeploymentStatus (failure)');
                return;
              }
              await github.rest.repos.createDeploymentStatus({
                owner: context.repo.owner,
                repo: context.repo.repo,
                deployment_id: deploymentId,
                state: 'failure',
                description: 'Deployment failed',
                environment: '${{ env.DEPLOY_ENV }}'
              });
            } catch (err) {
              console.log('createDeploymentStatus (failure) skipped due to error:', String(err));
            }
