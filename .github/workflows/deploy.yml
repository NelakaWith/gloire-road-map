name: Deploy

on:
  workflow_dispatch: {}
  push:
    tags:
      - "v*"
  release:
    types: [published, created]
  workflow_run:
    workflows: ["Release"]
    types: [completed]

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      deployments: write
    if: ${{ github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success' }}
    env:
      DEPLOY_TAG: ${{ github.event_name == 'release' && github.event.release.tag_name || (github.ref_type == 'tag' && github.ref_name) || '' }}
    steps:
      - name: Determine DEPLOY_TAG from latest release (when triggered by Release workflow)
        if: ${{ github.event_name == 'workflow_run' }}
        uses: actions/github-script@v6
        with:
          script: |
            // Query the repository for the most recent release and export its tag
            const latest = await github.rest.repos.getLatestRelease({
              owner: context.repo.owner,
              repo: context.repo.repo
            });
            const tag = latest.data.tag_name;
            require('fs').appendFileSync(process.env.GITHUB_ENV, `DEPLOY_TAG=${tag}\n`);
            console.log(`Determined DEPLOY_TAG=${tag}`);
            return tag;

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true
          ref: ${{ env.DEPLOY_TAG != '' && env.DEPLOY_TAG || (github.event_name == 'release' && github.event.release.tag_name || github.ref) }}

      - name: Create GitHub Deployment
        id: create_deployment
        uses: actions/github-script@v6
        with:
          script: |
            try {
              const ref = process.env.DEPLOY_TAG || github.ref;
              console.log('Creating deployment for ref:', ref);
              const response = await github.rest.repos.createDeployment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: ref,
                required_contexts: [],
                environment: 'production',
                auto_merge: false,
                description: 'Deployment triggered by CI',
                transient_environment: false
              });
              const id = response && response.data && response.data.id ? String(response.data.id) : '';
              console.log('Create deployment response id:', id);
              console.log('Full response data:', JSON.stringify(response.data || {}));
              // Export a clean numeric id to GITHUB_ENV so later steps can read it reliably
              try {
                require('fs').appendFileSync(process.env.GITHUB_ENV, `DEPLOYMENT_ID=${id}\n`);
                console.log('Exported DEPLOYMENT_ID to GITHUB_ENV');
              } catch (e) {
                console.warn('Failed to write DEPLOYMENT_ID to GITHUB_ENV:', String(e));
              }
              // Mark the deployment as in_progress so the GitHub UI doesn't show it as "Ready to deploy (idle)"
              try {
                const numericId = Number(id);
                if (numericId && !Number.isNaN(numericId)) {
                  console.log('Setting deployment status to in_progress for id:', numericId);
                  await github.rest.repos.createDeploymentStatus({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    deployment_id: numericId,
                    state: 'in_progress',
                    description: 'Deployment started by CI',
                    environment: 'production'
                  });
                } else {
                  console.log('Skipping in_progress status: invalid deployment id');
                }
              } catch (err) {
                console.error('Failed to set in_progress status:', String(err));
              }
              core.setOutput('result', id);
              if (!id) throw new Error('createDeployment returned empty id');
              return id;
            } catch (err) {
              console.error('Create deployment failed:', String(err));
              throw err;
            }

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Build frontend
        working-directory: frontend
        run: |
          npm install
          npm run build

      - name: Copy files to droplet via SSH
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.DROPLET_HOST }}
          username: ${{ secrets.DROPLET_USER }}
          key: ${{ secrets.DROPLET_SSH_KEY }}
          source: .
          target: ~/gloire-road-map
          rm: true

      - name: Run deploy script on droplet
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DROPLET_HOST }}
          username: ${{ secrets.DROPLET_USER }}
          key: ${{ secrets.DROPLET_SSH_KEY }}
          script: |
            cd ~/gloire-road-map/backend

            # Create .env file from GitHub secrets
            echo "Creating .env file from secrets..."
            cat > .env << EOF
            # Backend environment variables (auto-generated by deploy script)
            PORT=3001
            CORS_ORIGIN=https://roadmap.nelakawithanage.com/

            # Database configuration
            DB_HOST=localhost
            DB_NAME=${{ secrets.DB_NAME }}
            DB_USER=${{ secrets.DB_USER }}
            DB_PASSWORD=${{ secrets.DB_PASS }}

            # JWT secret for authentication
            JWT_SECRET=${{ secrets.JWT_SECRET }}
            EOF

            npm install
            pm2 restart server.js || pm2 start server.js --name gloire-road-map-backend
            cd ~/gloire-road-map/frontend
            npm install
            npm run build

            # Ensure NGINX live folder exists and is owned by www-data
            if sudo -n true 2>/dev/null; then
              sudo mkdir -p /var/www/gloire-road-map-live
              sudo chown -R www-data:www-data /var/www/gloire-road-map-live

              # Copy build to NGINX live folder
              sudo rm -rf /var/www/gloire-road-map-live/* || true
              sudo cp -r dist/* /var/www/gloire-road-map-live/ || true
              sudo chown -R www-data:www-data /var/www/gloire-road-map-live || true
            else
              echo "Skipping sudo-owned NGINX steps: deploy user cannot run sudo without a password"
            fi

            # (Optional) Run DB import if dump file exists and DB secrets are set
            if [ -f backend/migrations/dump.sql ]; then
              if [ -n "${{ secrets.DB_USER }}" ] && [ -n "${{ secrets.DB_PASS }}" ] && [ -n "${{ secrets.DB_NAME }}" ]; then
                echo "Importing backend/migrations/dump.sql to database ${{ secrets.DB_NAME }}"
                mysql -u"${{ secrets.DB_USER }}" -p"${{ secrets.DB_PASS }}" "${{ secrets.DB_NAME }}" < backend/migrations/dump.sql || echo "mysql import failed"
              else
                echo "DB credentials not provided in secrets; skipping DB import"
              fi
            else
              echo "No backend/migrations/dump.sql found; skipping DB import"
            fi

            # (Optional) Restart nginx if using static hosting
            if sudo -n true 2>/dev/null; then
              sudo systemctl reload nginx || echo "nginx reload failed"
            else
              echo "Skipping nginx reload: deploy user cannot run sudo without a password"
            fi

      - name: Mark deployment as successful
        if: ${{ success() && steps.create_deployment.outputs.result != '' }}
        uses: actions/github-script@v6
        env:
          DEPLOYMENT_ID: ${{ steps.create_deployment.outputs.result }}
        with:
          script: |
            try {
              const raw = process.env.DEPLOYMENT_ID || '';
              // Strip any non-digit characters (handles quoted values like "3060155420")
              const digits = String(raw).replace(/\D/g, '');
              const deploymentId = Number(digits);
              if (!digits || Number.isNaN(deploymentId) || deploymentId <= 0) {
                console.log('No valid deployment id found, skipping createDeploymentStatus (success)');
                return;
              }
              await github.rest.repos.createDeploymentStatus({
                owner: context.repo.owner,
                repo: context.repo.repo,
                deployment_id: deploymentId,
                state: 'success',
                description: 'Deployment succeeded',
                environment: 'production'
              });
            } catch (err) {
              console.log('createDeploymentStatus (success) skipped due to error:', String(err));
            }

      - name: Mark deployment as failed
        if: ${{ failure() && steps.create_deployment.outputs.result != '' }}
        uses: actions/github-script@v6
        env:
          DEPLOYMENT_ID: ${{ steps.create_deployment.outputs.result }}
        with:
          script: |
            try {
              const raw = process.env.DEPLOYMENT_ID || '';
              const digits = String(raw).replace(/\D/g, '');
              const deploymentId = Number(digits);
              if (!digits || Number.isNaN(deploymentId) || deploymentId <= 0) {
                console.log('No valid deployment id found, skipping createDeploymentStatus (failure)');
                return;
              }
              await github.rest.repos.createDeploymentStatus({
                owner: context.repo.owner,
                repo: context.repo.repo,
                deployment_id: deploymentId,
                state: 'failure',
                description: 'Deployment failed',
                environment: 'production'
              });
            } catch (err) {
              console.log('createDeploymentStatus (failure) skipped due to error:', String(err));
            }
